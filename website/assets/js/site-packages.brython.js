__BRYTHON__.use_VFS = true;
var scripts = {"$timestamp": 1754386234506, "sokobanpy.sokobanpy": [".py", "''\n\n\n\n\n\nfrom collections import deque\n\n\n__version__=\"1.3.0\"\n\nDEFAULT_LEVEL_STRING=(\n\"\"\n+\"##########\\n\"\n+\"#        #\\n\"\n+\"#  $  +  #\\n\"\n+\"#        #\\n\"\n+\"##########\\n\"\n)\n\n\nclass SokobanVector:\n ''\n\n\n\n\n\n\n\n \n \n def __init__(self,r,c):\n  ''\n\n\n\n\n  \n  self.r=r\n  self.c=c\n  \n def __repr__(self):\n  ''\n\n\n\n  \n  return f\"{self.__class__.__name__}(r={self.r}, c={self.c})\"\n  \n def __add__(self,other):\n  ''\n\n\n\n\n\n\n\n\n\n  \n  if not isinstance(other,self.__class__):\n   raise TypeError(\n   \"unsupported operand type(s) for +: \"\n   +f\"'{self.__class__.__name__}' \"\n   +f\"and '{other.__class__.__name__}'\"\n   )\n  return self.__class__(self.r+other.r,self.c+other.c)\n  \n def __sub__(self,other):\n  ''\n\n\n\n\n\n\n\n\n\n  \n  if not isinstance(other,self.__class__):\n   raise TypeError(\n   \"unsupported operand type(s) for -: \"\n   +f\"'{self.__class__.__name__}' \"\n   +f\"and '{other.__class__.__name__}'\"\n   )\n  return self.__class__(self.r -other.r,self.c -other.c)\n  \n def __neg__(self):\n  ''\n\n\n\n  \n  return self.__class__(-self.r,-self.c)\n  \n def __eq__(self,other):\n  ''\n\n\n\n\n\n\n  \n  return (\n  isinstance(other,self.__class__)\n  and (self.r ==other.r)\n  and (self.c ==other.c)\n  )\n  \n def __hash__(self):\n  ''\n\n\n\n  \n  return hash((self.r,self.c))\n  \n  \nclass Sokoban:\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n SPACE=\" \"\n WALL=\"#\"\n GOAL=\".\"\n BOX=\"$\"\n BOX_IN_GOAL=\"*\"\n PLAYER=\"@\"\n PLAYER_IN_GOAL=\"+\"\n CHAR_SET={SPACE,WALL,GOAL,BOX,BOX_IN_GOAL,PLAYER,PLAYER_IN_GOAL}\n \n RIGHT=SokobanVector(0,1)\n DOWN=SokobanVector(1,0)\n LEFT=-RIGHT\n UP=-DOWN\n DIRECTION_SET={RIGHT,DOWN,LEFT,UP}\n \n def __init__(self,level_string=DEFAULT_LEVEL_STRING,undo_limit=None ):\n  ''\n\n\n\n\n\n\n  \n  self.undo_limit=undo_limit\n  self._from_string(level_string)\n  \n def __str__(self):\n  ''\n  grid=self.to_grid()\n  return \"\\n\".join([\"\".join(line)for line in grid])\n  \n def _reset(self):\n  ''\n  self.player=None\n  self.walls=set()\n  self.goals=set()\n  self.boxes=set()\n  self.nrow=0\n  self.ncol=0\n  self.nmove=0\n  self.npush=0\n  self.history=deque((),self.undo_limit)\n  \n def _from_grid(self,grid):\n  ''\n\n\n\n  \n  self._reset()\n  \n  for r,row in enumerate(grid):\n   for c,char in enumerate(row):\n    pos=SokobanVector(r,c)\n    if char ==self.WALL:\n     self.walls.add(pos)\n    elif char ==self.GOAL:\n     self.goals.add(pos)\n    elif char ==self.BOX:\n     self.boxes.add(pos)\n    elif char ==self.BOX_IN_GOAL:\n     self.goals.add(pos)\n     self.boxes.add(pos)\n    elif char ==self.PLAYER:\n     self.player=pos\n    elif char ==self.PLAYER_IN_GOAL:\n     self.goals.add(pos)\n     self.player=pos\n     \n  self.nrow=len(grid)\n  self.ncol=max(len(row)for row in grid)\n  \n def _from_string(self,level_string):\n  ''\n\n\n\n  \n  \n  grid=[\n  [char for char in line.rstrip()]\n  for line in level_string.split(\"\\n\")\n  if all(char in self.CHAR_SET for char in line.rstrip())\n  ]\n  \n  grid=[row for row in grid if \"\".join(row).rstrip()]\n  \n  num_indent=min(len(row)-len(\"\".join(row).lstrip())for row in grid)\n  \n  grid=[row[num_indent:]for row in grid]\n  \n  self._from_grid(grid)\n  \n def to_grid(self):\n  ''\n\n\n\n  \n  grid=[[self.SPACE for c in range(self.ncol)]for r in range(self.nrow)]\n  \n  for wall in self.walls:\n   grid[wall.r][wall.c]=self.WALL\n   \n  for goal in self.goals:\n   grid[goal.r][goal.c]=self.GOAL\n   \n  for box in self.boxes:\n   if box in self.goals:\n    grid[box.r][box.c]=self.BOX_IN_GOAL\n   else :\n    grid[box.r][box.c]=self.BOX\n    \n  if self.player is not None :\n   if self.player in self.goals:\n    grid[self.player.r][self.player.c]=self.PLAYER_IN_GOAL\n   else :\n    grid[self.player.r][self.player.c]=self.PLAYER\n    \n  return grid\n  \n def covers(self,position):\n  ''\n\n\n\n\n\n\n  \n  return (0 <=position.r <self.nrow)and (0 <=position.c <self.ncol)\n  \n def can_move(self,direction):\n  ''\n\n\n\n\n\n\n  \n  if self.player is None :\n   return False\n   \n  new_player=self.player+direction\n  new_box=new_player+direction\n  \n  if (new_player in self.walls)or (not self.covers(new_player)):\n   return False\n  elif new_player in self.boxes:\n   if (new_box in (self.boxes |self.walls))or (not self.covers(new_box)):\n    return False\n   else :\n    return True\n  else :\n   return True\n   \n def move(self,direction):\n  ''\n\n\n\n\n\n\n  \n  if not self.can_move(direction):\n   return False\n   \n  old_player=self.player\n  self.player=self.player+direction\n  self.nmove +=1\n  \n  if self.player in self.boxes:\n   self.boxes.discard(self.player)\n   new_box=self.player+direction\n   self.boxes.add(new_box)\n   self.npush +=1\n   self.history.append((old_player,self.player,new_box))\n  else :\n   self.history.append((old_player,self.player,None ))\n   \n  return True\n  \n def undo(self):\n  ''\n\n\n\n  \n  if not self.history:\n   return False\n   \n  old_player,new_player,new_box=self.history.pop()\n  self.player=old_player\n  self.nmove -=1\n  \n  if new_box:\n   self.boxes.discard(new_box)\n   self.boxes.add(new_player)\n   self.npush -=1\n   \n  return True\n  \n def is_solved(self):\n  ''\n\n\n\n  \n  return self.goals ==self.boxes\n  \n def find_path(self,target_pos):\n  ''\n\n\n\n\n\n\n  \n  if self.player is None :\n   return None\n   \n  if not self.covers(target_pos):\n   return None\n   \n  grid=self.to_grid()\n  if grid[target_pos.r][target_pos.c]not in (self.SPACE,self.GOAL):\n   return None\n   \n  queue=deque([(self.player,[])],self.nrow+self.ncol)\n  visited=set()\n  \n  while queue:\n   curr_pos,curr_path=queue.popleft()\n   if curr_pos ==target_pos:\n    return curr_path\n    \n   for direction in self.DIRECTION_SET:\n    new_pos=curr_pos+direction\n    if (\n    self.covers(new_pos)\n    and (grid[new_pos.r][new_pos.c]in (self.SPACE,self.GOAL))\n    and (new_pos not in visited)\n    ):\n     new_path=curr_path+[new_pos]\n     queue.append((new_pos,new_path))\n     visited.add(new_pos)\n     \n  return None\n", ["collections"]], "sokobanpy": [".py", "''\n\n\n\n\n\nfrom .sokobanpy import (\n__version__,\nSokobanVector,\nSokoban,\n)\n\n__all__=[\n\"SokobanVector\",\n\"Sokoban\",\n]\n", ["sokobanpy.sokobanpy"], 1]}
__BRYTHON__.update_VFS(scripts)
